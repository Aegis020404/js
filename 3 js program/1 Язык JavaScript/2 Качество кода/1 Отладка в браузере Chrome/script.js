// Отладка – это процесс поиска и исправления ошибок в скрипте. Все современные браузеры и большинство других сред разработки поддерживают инструменты для отладки – специальный графический интерфейс, который сильно упрощает отладку. Он также позволяет по шагам отследить, что именно происходит в нашем коде.

    // Панель Исходный код (sources)

    // Кнопка-переключатель  откроет вкладку со списком файлов.
    // https://learn.javascript.ru/article/debugging-chrome/debugging/index.html текстовая страница


// Интерфейс состоит из трёх зон:

    // В зоне Resources (Ресурсы) показаны файлы HTML, JavaScript, CSS, включая изображения, используемые на странице. Здесь также могут быть файлы различных расширений Chrome.
    // Зона Source показывает исходный код.
    // Наконец, зона Information and control (Сведения и контроль) отведена для отладки, вскоре мы к ней вернёмся.


// Консоль
    // При нажатии на клавишу Esc в нижней части экрана вызывается консоль, где можно вводить команды и выполнять их клавишей Enter.


// Точка остановка(breakpoints)
    // Давайте разберёмся, как работает код нашей тестовой страницы. В файле hello.js щёлкните по строчке номер 4. Да, щёлкайте именно по самой цифре, не по коду.

    // Ура! Вы поставили точку останова. А теперь щёлкните по цифре 8 на восьмой линии. Номер строки будет окрашен в синий цвет.
    // Точка останова – это участок кода, где отладчик автоматически приостановит исполнение JavaScript.

    // Быстро переместиться к любой точке останова в коде – нужно щёлкнуть по точке в правой части экрана.
    // Временно деактивировать точку – в общем списке снимите галочку напротив ненужной в данный момент точки.
    // Удалить точку – щёлкните по ней правой кнопкой мыши и выберите Remove (Удалить).
    // …и так далее.


// Команда Debugger
    // Выполнение кода можно также приостановить с помощью команды debugger прямо изнутри самого кода:
    function hello (name){
        let phrase = `Hello , ${name}`
        debugger;// здесь выполнение прерывается
        say(phase)
    }
    // Способ удобен тем, что можно продолжить работать в редакторе кода без необходимости переключения в браузер для выставления точки останова.


// Остановимся и оглядимся
    // Watch показывает текущие значения выражений.

    // Нажмите на + и введите выражение. В процессе выполнения отладчик автоматически пересчитывает и выводит его значение.

    // Call Stack показывает последовательность вызовов функций.

    // В нашем примере отладчик работает с функцией hello(), вызванной скриптом из файла index.html (там нет функции, поэтому вызов «анонимный»).

    // При нажатии на элемент списка (например, на «anonymous») отладчик переходит к соответствующему коду, и нам представляется возможность его проанализировать.

    // Scope показывает текущие переменные.

    // В Local отображаются локальные переменные функций, а их значения подсвечены в исходном коде.

    // В Global перечисляются глобальные переменные (т.е. объявленные за пределами функций).

    // Не обращайте пока внимание на ключевое слово this – его мы изучим чуть позже.


// Пошаговое выполнение скрипта
    // А теперь давайте пошагаем по нашему коду.

    // В правой части панели для этого есть несколько кнопок. Рассмотрим их.

    //  – продолжить выполнение. Быстрая клавиша – F8.
    // Возобновляет выполнение кода. Если больше нет точек останова, отладчик прекращает работу и позволяет приложению работать дальше.

    // Выполнение кода возобновилось, дошло до другой точки останова внутри say(), и отладчик снова приостановил выполнение. Обратите внимание на пункт «Call stack» справа: в списке появился ещё один вызов. Мы теперь внутри функции say().

    //  – сделать шаг (выполнить следующую команду), не заходя в функцию. Быстрая клавиша – F10.
    // Если мы нажмём на неё – будет вызван alert. Важно: на месте alert может быть любая другая функция, выполнение просто перешагнёт через неё, полностью игнорируя её содержимое.

    //  – сделать шаг. Быстрая клавиша – F11.
    // В отличие от предыдущего примера, здесь мы «заходим» во вложенные функции и шаг за шагом проходим по скрипту.

    //  – продолжить выполнение до завершения текущей функции. Быстрая клавиша – Shift+F11.
    // Выполнение кода остановится на самой последней строчке текущей функции. Этот метод применяется, когда мы случайно нажали  и зашли в функцию, но нам она неинтересна и мы как можно скорее хотим из неё выбраться.

    //  – активировать/деактивировать все точки останова.
    // Эта кнопка не влияет на выполнение кода, она лишь позволяет массово включить/отключить точки останова.

    //  – разрешить/запретить остановку выполнения в случае возникновения ошибки.
    // Если опция включена и инструменты разработчика открыты, любая ошибка в скрипте приостанавливает выполнение кода, что позволяет его проанализировать. Поэтому если скрипт завершается с ошибкой, открываем отладчик, включаем эту опцию, перезагружаем страницу и локализуем проблему.

    // Continue to here
    // Если щёлкнуть правой кнопкой мыши по строчке кода, в контекстном меню можно выбрать опцию «Continue to here» («продолжить до этого места»).

    // Этот метод используется, когда нам нужно продвинуться на несколько шагов вперёд до нужной строки, но лень выставлять точки останова.


// Логирование
    console.log()//Если правильно выстроить логирование в приложении, то можно и без отладчика разобраться, что происходит в коде.


    // Приостановить выполнение скрипта можно тремя способами:

    // Точками останова.
    // Использованием в коде команды debugger.
    // При ошибке (если инструменты разработчика открыты и опция  включена).
    // При остановке мы можем отлаживать – проанализировать переменные и пошагово пройти по процессу, что поможет отыскать проблему.
    
    // Нами описаны далеко не все инструменты разработчика. С полным руководством можно ознакомиться здесь: https://developers.google.com/web/tools/chrome-devtools.


// Автоматизированные средства проверки (линтеры)
    // Автоматизированные средства проверки, так называемые «линтеры» – это инструменты, которые могут автоматически проверять стиль вашего кода и вносить предложения по его улучшению.
    
    // Самое замечательное в них то, что проверка стиля может также найти программные ошибки, такие как опечатки в именах переменных или функций. Из-за этой особенности использовать линтер рекомендуется, даже если вы не хотите придерживаться какого-то конкретного «стиля кода».
    
    // Вот некоторые известные инструменты для проверки:
    
    // JSLint – проверяет код на соответствие стилю JSLint, в онлайн-интерфейсе вверху можно ввести код, а внизу – различные настройки проверки, чтобы попробовать её в действии.
    // JSHint – больше проверок, чем в JSLint.
    // ESLint – пожалуй, самый современный линтер.
    // Все они, в общем-то, работают. Автор пользуется ESLint.
    
    // Большинство линтеров интегрированы со многими популярными редакторами: просто включите плагин в редакторе и настройте стиль.
    
    // Например, для ESLint вы должны выполнить следующее:
    
    // Установите Node.JS.
    // Установите ESLint с помощью команды npm install -g eslint (npm – установщик пакетов JavaScript).
    // Создайте файл конфигурации с именем .eslintrc в корне вашего JavaScript-проекта (в папке, содержащей все ваши файлы).
    // Установите/включите плагин для вашего редактора, который интегрируется с ESLint. У большинства редакторов он есть.
    // Вот пример файла .eslintrc:
    
    // {
    //   "extends": "eslint:recommended",
    //   "env": {
    //     "browser": true,
    //     "node": true,
    //     "es6": true
    //   },
    //   "rules": {
    //     "no-console": 0,
    //     "indent": ["warning", 2]
    //   }
    // }
    // Здесь директива "extends" означает, что конфигурация основана на наборе настроек «eslint:recommended». После этого мы уточняем наши собственные.
    
    // Кроме того, возможно загрузить наборы правил стиля из сети и расширить их. Смотрите https://eslint.org/docs/user-guide/getting-started для получения более подробной информации об установке.
    
    // Также некоторые среды разработки имеют встроенные линтеры, возможно, удобные, но не такие гибкие в настройке, как ESLint.
    

// Итого
    // Все правила синтаксиса, описанные в этой главе (и в ссылках на руководства по стилю), направлены на повышение читаемости вашего кода. О любых можно поспорить.
    
    // Когда мы думаем о написании «лучшего» кода, мы должны задать себе вопросы: «Что сделает код более читаемым и лёгким для понимания?» и «Что может помочь избегать ошибок?». Это – основные моменты, о которых следует помнить при выборе и обсуждении стилей кода.
    
    // Чтение популярных руководств по стилю позволит вам быть в курсе лучших практик и последних идей и тенденций в стилях написания кода.





























