// По спецификации, в качестве ключей для свойств объекта могут использоваться только строки или символы. Ни числа, ни логические значения не подходят, разрешены только эти два типа данных.

// До сих пор мы видели только строки. Теперь давайте разберём символы, увидим, что хорошего они нам дают.


// Символы
//     «Символ» представляет собой уникальный идентификатор.

//     Создаются новые символы с помощью функции Symbol():
    let id = Symbol();

    // Создаём символ id с описанием (именем) "id"
    let id1 = Symbol('id');
    let id2 = Symbol('id');
    console.log(id1 == id2);// false


    console.log(id2);// TypeError: Cannot convert a Symbol value to a string 
    console.log(id2.toString()); // Symbol(id), теперь работает

    console.log(id2.description); //id


// Cкрытые свойства
    let user = {
        name: "Вася",
    };

    user[id1] = 1;
    console.log(user[id1]);//1


    // Объявляем в нашем скрипте свойство "id"
    user.id = "Наш идентификатор";

    // ...другой скрипт тоже хочет свой идентификатор...

    user.id = "Их идентификатор"
    // Ой! Свойство перезаписано сторонней библиотекой!


// Символы в литеральном объекте
    user = {
        age:30,
        name: "Вася",
        [id]: 123, // просто 'id: 123' не сработает  
    }


// Символы игнорируются циклом for..in
    
    for(let key in user) console.log(key)// age,name (свойства с ключом-символом нет среди перечисленных)

    // хотя прямой доступ по символу работает
    console.log('Напрямую ' + user[id] );// Напрямую 123
    // Это – часть общего принципа «сокрытия символьных свойств». Если другая библиотека или скрипт будут работать с нашим объектом, то при переборе они не получат ненароком наше символьное свойство. Object.keys(user) также игнорирует символы.

    let clone = Object.assign({},user);

    console.log(clone[id]);//123


// Глобальные символы

    // читаем символ из глобального реестра и записываем его в переменную
    let id3 = Symbol.for('id1');

    // читаем его снова в другую переменную (возможно, из другого места кода)
    let id4 = Symbol.for('id2');

    // проверяем -- это один и тот же символ
    console.log( id3 == id4 )


    // Symbol.keyFor
        // Для глобальных символов, кроме Symbol.for(key), который ищет символ по имени, существует обратный метод: Symbol.keyFor(sym), который, наоборот, принимает глобальный символ и возвращает его имя.

        // получаем символ по имени

        let sym = Symbol.for('name');
        let sym2 = Symbol.for('id');

        // получаем символ по имени
        console.log(Symbol.keyFor(sym) ); // name
        console.log(Symbol.keyFor(sym2) ); // id

        // Внутри метода Symbol.keyFor используется глобальный реестр символов для нахождения имени символа. Так что этот метод не будет работать для неглобальных символов. Если символ неглобальный, метод не сможет его найти и вернёт undefined.

        let globalSymbol = Symbol.for('name');
        let localSymbol = Symbol('name');

        console.log( Symbol.keyFor(globalSymbol) );// name, глобальный символ
        console.log( Symbol.keyFor(localSymbol) );// undefined, локальный символ

        console.log( localSymbol.description); // name


        // Системные символы
        // Существует множество «системных» символов, использующихся внутри самого JavaScript, и мы можем использовать их, чтобы настраивать различные аспекты поведения объектов.
        
        // Эти символы перечислены в спецификации в таблице Well-known symbols:
        
        // Symbol.hasInstance
        // Symbol.isConcatSpreadable
        // Symbol.iterator
        // Symbol.toPrimitive
        // …и так далее.
        // В частности, Symbol.toPrimitive позволяет описать правила для объекта, согласно которым он будет преобразовываться к примитиву. Мы скоро увидим его применение.
        
        // С другими системными символами мы тоже скоро познакомимся, когда будем изучать соответствующие возможности языка.